EVSTimeGrid.mixin({

    // Utility for generating event skin-related CSS properties
	getEventSkinCss: function(event) {
	    return {};
		/*var view = this.view;
		var source = event.source || {};
		var eventColor = event.color;
		var sourceColor = source.color;
		var optionColor = view.opt('eventColor');

		return {
			'background-color':
				event.backgroundColor ||
				eventColor ||
				source.backgroundColor ||
				sourceColor ||
				view.opt('eventBackgroundColor') ||
				optionColor,
			'border-color':
				event.borderColor ||
				eventColor ||
				source.borderColor ||
				sourceColor ||
				view.opt('eventBorderColor') ||
				optionColor,
			color:
				event.textColor ||
				source.textColor ||
				view.opt('eventTextColor')
		};*/
	},
    // Renders the HTML for a single event segment's default rendering
	fgSegHtml: function(seg, disableResizing) {
		var view = this.view;
		var event = seg.event;
		var isDraggable = view.isEventDraggable(event);
		var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);
		var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);
		var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
		//var skinCss = cssToStr(this.getEventSkinCss(event));
		var timeText;
		var fullTimeText; // more verbose time text. for the print stylesheet
		var startTimeText; // just the start time text

		classes.unshift('fc-time-grid-event', 'fc-v-event');
		if(event.cssClasses)
		{
		    classes.push(event.cssClasses);
        }

		if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...
			// Don't display time text on segments that run entirely through a day.
			// That would appear as midnight-midnight and would look dumb.
			// Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
			if (seg.isStart || seg.isEnd) {
				timeText = this.getEventTimeText(seg);
				fullTimeText = this.getEventTimeText(seg, 'LT');
				startTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false
			}
		} else {
			// Display the normal time text for the *event's* times
			timeText = this.getEventTimeText(event);
			fullTimeText = this.getEventTimeText(event, 'LT');
			startTimeText = this.getEventTimeText(event, null, false); // displayEnd=false
		}

        if(event.template)
        {
            var t_slot = '<a class="' + classes.join(' ') + '" >'+event.template+'</div>';
            return t_slot;
        }else if(seg.isHelper && view.options.helperTemplate !== '')
        {
            var h_slot = '<a class="' + classes.join(' ') + ' '+view.options.helperCssClass+'" >'+view.options.helperTemplate+'</div>';
            return h_slot;
        }
        else
        {
            return TimeGrid.prototype.fgSegHtml.apply(this, arguments);
        }
	},
	renderHelperSegs:
	function(segs, sourceSeg) {
	    segs[0].isHelper = true;
	    TimeGrid.prototype.renderHelperSegs.apply(this, arguments);
	}
})